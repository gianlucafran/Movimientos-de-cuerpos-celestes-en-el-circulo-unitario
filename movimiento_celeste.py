# -*- coding: utf-8 -*-
"""movimiento celeste.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16jQPcVaP17b9RKDoszENe89Py-hLmfrb

# Dataset de posiones y velocidades iniciales del sistema solar
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
planetas=[{'mass_Msun': 1.0,
  'name': 'Sun',
  'vx_AUyr': 0.0,
  'vy_AUyr': 0.0,
  'vz_AUyr': 0.0,
  'x_AU': 0.0,
  'y_AU': 0.0,
  'z_AU': 0.0},
 {'mass_Msun': 1.66e-07,
  'name': 'Mercury',
  'vx_AUyr': 0.0,
  'vy_AUyr': 9.96,
  'vz_AUyr': 0.0,
  'x_AU': 0.39,
  'y_AU': 0.0,
  'z_AU': 0.01},
 {'mass_Msun': 2.45e-06,
  'name': 'Venus',
  'vx_AUyr': 0.0,
  'vy_AUyr': 7.39,
  'vz_AUyr': 0.0,
  'x_AU': 0.72,
  'y_AU': 0.0,
  'z_AU': -0.01},
 {'mass_Msun': 3e-06,
  'name': 'Earth',
  'vx_AUyr': 0.0,
  'vy_AUyr': 6.28,
  'vz_AUyr': 0.0,
  'x_AU': 1.0,
  'y_AU': 0.0,
  'z_AU': 0.0167},
 {'mass_Msun': 3.22e-07,
  'name': 'Mars',
  'vx_AUyr': 0.0,
  'vy_AUyr': 5.08,
  'vz_AUyr': 0.0,
  'x_AU': 1.52,
  'y_AU': 0.0,
  'z_AU': 0.04},
 {'mass_Msun': 0.00095,
  'name': 'Jupiter',
  'vx_AUyr': 0.0,
  'vy_AUyr': 2.75,
  'vz_AUyr': 0.0,
  'x_AU': 5.2,
  'y_AU': 0.0,
  'z_AU': -0.05},
 {'mass_Msun': 0.00029,
  'name': 'Saturn',
  'vx_AUyr': 0.0,
  'vy_AUyr': 2.03,
  'vz_AUyr': 0.0,
  'x_AU': 9.5,
  'y_AU': 0.0,
  'z_AU': 0.1},
 {'mass_Msun': 4.4e-05,
  'name': 'Uranus',
  'vx_AUyr': 0.0,
  'vy_AUyr': 1.43,
  'vz_AUyr': 0.0,
  'x_AU': 19.2,
  'y_AU': 0.0,
  'z_AU': -0.2},
 {'mass_Msun': 5.1e-05,
  'name': 'Neptune',
  'vx_AUyr': 0.0,
  'vy_AUyr': 1.14,
  'vz_AUyr': 0.0,
  'x_AU': 30.1,
  'y_AU': 0.0,
  'z_AU': 0.3}]
dff=pd.DataFrame(planetas)
dff.to_csv(r"C:\Users\CixoY\OneDrive\Desktop\cursoanalisis\solar_system_3d.csv", index=False)

'''
Se cargan las condiciones inciales del sistema solar:
- Masas en masas solares (M-sun)
- Posicones en unidades astronomicas (AU)
- Velocidades iniciales en unidades astronomicas por año (AU/año)
-Incluye Sol + 8 planetas principales del sistema solar.

'''

"""# Problema de 2 cuerpos en S^1
## Se realiza con Runge-kutta 4
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# =====================================================
#   MÉTODO RUNGE–KUTTA DE 4° ORDEN (GENÉRICO)
# =====================================================
def rk4_step(f, t, y, dt, *args):
    k1 = f(t, y, *args)
    k2 = f(t + dt/2, y + dt*k1/2, *args)
    k3 = f(t + dt/2, y + dt*k2/2, *args)
    k4 = f(t + dt, y + dt*k3, *args)
    return y + (dt/6)*(k1 + 2*k2 + 2*k3 + k4)

# =====================================================
#   PARTE A — PROBLEMA DE 2 CUERPOS EN S^1
#   Ec. (2.3) de la tesis: θ¨ = -M/θ² + M/(2π–θ)²
# =====================================================
def theta_rhs(t, y, M, eps=1e-6):
    theta, theta_dot = y
    theta = np.mod(theta, 2*np.pi)
    theta = np.clip(theta, eps, 2*np.pi - eps)
    theta_dd = - M/(theta**2) + M/((2*np.pi - theta)**2)
    return np.array([theta_dot, theta_dd])

def simulate_S1_RK4(m1, m2, theta0, theta_dot0, T=20, dt=0.001):
    M = m1 + m2
    N = int(T/dt)
    t = np.zeros(N)
    theta = np.zeros(N)
    theta_dot = np.zeros(N)

    y = np.array([theta0, theta_dot0])
    theta[0], theta_dot[0] = y
    for i in range(1, N):
        t[i] = t[i-1] + dt
        y = rk4_step(theta_rhs, t[i-1], y, dt, M)
        theta[i], theta_dot[i] = y

    theta1 = - (m2/M) * theta
    theta2 = + (m1/M) * theta

    x1, y1 = np.cos(theta1), np.sin(theta1)
    x2, y2 = np.cos(theta2), np.sin(theta2)
    return t, x1, y1, x2, y2

# =====================================================
#   PARTE B — ORBITAS DE PLANETAS EN 2D
#   Newton clásico con RK4
# =====================================================
G = 4 * np.pi**2   # AU^3 / (Msun * yr^2)

def planet_rhs(t, y, M_sun):
    x, y_pos, vx, vy = y
    r3 = (x*x + y_pos*y_pos)**1.5 + 1e-12
    ax = - G * M_sun * x / r3
    ay = - G * M_sun * y_pos / r3
    return np.array([vx, vy, ax, ay])

def integrate_planet_RK4(x0, y0, vx0, vy0, T, dt=0.001, M_sun=1.0):
    N = int(T/dt)
    xs = np.zeros(N)
    ys = np.zeros(N)

    y = np.array([x0, y0, vx0, vy0])
    xs[0], ys[0] = x0, y0

    t = 0.0
    for i in range(1, N):
        y = rk4_step(planet_rhs, t, y, dt, M_sun)
        xs[i], ys[i] = y[0], y[1]
        t += dt

    return xs, ys

# =====================================================
#   MAIN
# =====================================================
if __name__ == "__main__":
    # ============================================
    #   A) SIMULACIÓN S^1 (TESIS)
    # ============================================
    m1 = 0.3
    m2 = 0.7
    theta0 = 1.0
    theta_dot0 = 0.0
    t, x1, y1, x2, y2 = simulate_S1_RK4(m1, m2, theta0, theta_dot0, T=20, dt=0.002)

    plt.figure(figsize=(6,6))
    plt.plot(x1, y1, label=f"m1 = {m1}")
    plt.plot(x2, y2, label=f"m2 = {m2}")
    plt.scatter(0,0, color='k', s=20)
    plt.title("Problema de 2 cuerpos en S¹ (RK4)")
    plt.axis('equal'); plt.grid(True); plt.legend()
    plt.show()

    # ============================================
    #   B) ÓRBITAS DE TODOS LOS PLANETAS (CSV)
    # ============================================


    planetas=[
        {'mass_Msun': 1.0, 'name': 'Sun', 'vx_AUyr': 0.0, 'vy_AUyr': 0.0, 'vz_AUyr': 0.0, 'x_AU': 0.0, 'y_AU': 0.0, 'z_AU': 0.0},
        {'mass_Msun': 1.66e-07, 'name': 'Mercury', 'vx_AUyr': 0.0, 'vy_AUyr': 9.96, 'vz_AUyr': 0.0, 'x_AU': 0.39, 'y_AU': 0.0, 'z_AU': 0.01},
        {'mass_Msun': 2.45e-06, 'name': 'Venus', 'vx_AUyr': 0.0, 'vy_AUyr': 7.39, 'vz_AUyr': 0.0, 'x_AU': 0.72, 'y_AU': 0.0, 'z_AU': -0.01},
        {'mass_Msun': 3e-06, 'name': 'Earth', 'vx_AUyr': 0.0, 'vy_AUyr': 6.28, 'vz_AUyr': 0.0, 'x_AU': 1.0, 'y_AU': 0.0, 'z_AU': 0.0167},
        {'mass_Msun': 3.22e-07, 'name': 'Mars', 'vx_AUyr': 0.0, 'vy_AUyr': 5.08, 'vz_AUyr': 0.0, 'x_AU': 1.52, 'y_AU': 0.0, 'z_AU': 0.04},
        {'mass_Msun': 0.00095, 'name': 'Jupiter', 'vx_AUyr': 0.0, 'vy_AUyr': 2.75, 'vz_AUyr': 0.0, 'x_AU': 5.2, 'y_AU': 0.0, 'z_AU': -0.05},
        {'mass_Msun': 0.00029, 'name': 'Saturn', 'vx_AUyr': 0.0, 'vy_AUyr': 2.03, 'vz_AUyr': 0.0, 'x_AU': 9.5, 'y_AU': 0.0, 'z_AU': 0.1},
        {'mass_Msun': 4.4e-05, 'name': 'Uranus', 'vx_AUyr': 0.0, 'vy_AUyr': 1.43, 'vz_AUyr': 0.0, 'x_AU': 19.2, 'y_AU': 0.0, 'z_AU': -0.2},
        {'mass_Msun': 5.1e-05, 'name': 'Neptune', 'vx_AUyr': 0.0, 'vy_AUyr': 1.14, 'vz_AUyr': 0.0, 'x_AU': 30.1, 'y_AU': 0.0, 'z_AU': 0.3}
    ]

    # Se crea y se guarda el data frame en un archivo local y accesible
    dff=pd.DataFrame(planetas)
    dff.to_csv("solar_system_3d.csv", index=False)

    df = pd.read_csv("solar_system_3d.csv")

    plt.figure(figsize=(8,8))
    for _, row in df.iterrows():
        name = row["name"]
        if name.lower() == "sun":
            plt.scatter(0,0, color="orange", s=150, label="Sun")
            continue

        x0 = row["x_AU"]
        y0 = row["y_AU"]
        vx0 = row["vx_AUyr"]
        vy0 = row["vy_AUyr"]

        a = np.sqrt(x0**2 + y0**2)
        T = np.sqrt(a**3)

        xs, ys = integrate_planet_RK4(x0, y0, vx0, vy0, T, dt=0.001)

        plt.plot(xs, ys, label=name)
        plt.scatter([x0],[y0], s=10)

    plt.title("Órbitas de los planetas (RK4, 1 periodo aprox.)")
    plt.xlabel("x (AU)")
    plt.ylabel("y (AU)")
    plt.axis("equal")
    plt.grid(True)
    plt.legend(bbox_to_anchor=(1.05,1), loc='upper left')
    plt.show()

'''
1. Método numérico
Se integra RK4 para sistemas de EDOs

2. Problema de dos cuerpos en Círculo (S^1)
"Simulación del problema restringuido en geometría circular"

3. Simulador del sistema solar
Ley de gravitación de Newton donde: F = -GM/r^2
Calcula 1 periodo orbital completo para cada planeta.

4. Dataset del sistema solar
Se aplican condiciones iniciales reales del sisitema solar

Lo que se puede observar en la primera imagen son dos cuerpos que están
gravitacionalmente y se mueven en un círculo. El cuerpo (m2) permanece cerca
del centro (lo que se ve de azul) mientras que el cuerpo menos pesado
(m1, lo que se ve de naranja) orbita a su alrededor con más variedad
de movimientos. Ambos giran alrededor de su centro de masa común,
representado por el punto negro.

'''

"""# Sitema regularizado del Problema de 2 cuerpos - Transoformación (q,p)"""

import numpy as np
import matplotlib.pyplot as plt

# =====================================================
#  RK4 genérico
# =====================================================
def rk4_step(f, t, y, dt, *args):
    k1 = f(t, y, *args)
    k2 = f(t + dt/2, y + dt*k1/2, *args)
    k3 = f(t + dt/2, y + dt*k2/2, *args)
    k4 = f(t + dt, y + dt*k3, *args)
    return y + (dt/6)*(k1 + 2*k2 + 2*k3 + k4)

# =====================================================
#  SISTEMA REGULARIZADO DE LA TESIS
#  dq/dτ = p
#  dp/dτ = -(2 h π² sin(q) cos(q)) / p
# =====================================================
def qp_rhs(t, y, M, h):
    q, p = y
    # Ecuación dp/dτ = -(2 h pi^2 sin q cos q)/p
    dp_dtau = -(2*h*(np.pi**2) * np.sin(q) * np.cos(q)) / (p + 1e-6)
    dq_dtau = p
    return np.array([dq_dtau, dp_dtau])

# =====================================================
#  SIMULACIÓN REGULARIZADA (TESIS)
# =====================================================
def simulate_regularized(m1, m2, theta0, theta_dot0, T_tau=50, dt=0.001):
    M = m1 + m2

    # Conversión theta → q
    q0 = theta0 / 2

    # p0 = dq/dτ = (dq/dt)*(dt/dτ) = (θ'/2)*(π² cos²(q))
    p0 = 0.5 * theta_dot0 * (np.pi**2) * (np.cos(q0)**2)

    # h desde la ecuación de energía
    denom = 2*(np.pi**2)*(np.cos(q0)**2)
    h = (p0**2 - 4*np.pi*M) / denom

    print(f"[INFO] M={M}, h={h}")

    N = int(T_tau / dt)
    qs = np.zeros(N)
    ps = np.zeros(N)

    y = np.array([q0, p0])
    qs[0], ps[0] = q0, p0

    tau = 0.0
    for i in range(1, N):
        y = rk4_step(qp_rhs, tau, y, dt, M, h)
        qs[i], ps[i] = y
        tau += dt

    # Reconstrucción θ(tau)
    theta = 2 * qs

    # Posiciones de cada masa
    theta1 = - (m2/M) * theta
    theta2 = + (m1/M) * theta

    x1, y1 = np.cos(theta1), np.sin(theta1)
    x2, y2 = np.cos(theta2), np.sin(theta2)

    return x1, y1, x2, y2, theta, qs, ps, h

m1 = 0.3
m2 = 0.7
theta0 = 1.0
theta_dot0 = 0.0

x1, y1, x2, y2, theta, q, p, h = simulate_regularized(
    m1, m2, theta0, theta_dot0,
    T_tau=50, dt=0.001
)

plt.figure(figsize=(6,6))
plt.plot(x1, y1, label="m1")
plt.plot(x2, y2, label="m2")
plt.scatter([0],[0], color='k')
plt.axis("equal"); plt.grid()
plt.title("Solución regularizada (q,p) — equivalente a solución elíptica")
plt.legend()
plt.show()

'''
Se usa una transformación regularizada que elimina singularidades
y mejora la estabilidad numérica.

La transformación que se realiza:
(0,0) -> (q,p)

Se mejor la precisión numérica.
'''

"""# Visualización 3D del campo Gravitacional del sol"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Constante gravitacional (normalizada)
G = 1.0

# --------------------------
# Posición y masa del Sol
# --------------------------
sun_pos = np.array([0.0, 0.0, 0.0])
sun_mass = 1.0

# --------------------------
# Grilla 3D para evaluar el campo
# --------------------------
grid_range = np.linspace(-3, 3, 7)
X, Y, Z = np.meshgrid(grid_range, grid_range, grid_range)

# Campo gravitacional
gx = np.zeros_like(X)
gy = np.zeros_like(Y)
gz = np.zeros_like(Z)

# --------------------------
# Calcular el campo
# --------------------------
for i in range(X.shape[0]):
    for j in range(X.shape[1]):
        for k in range(X.shape[2]):
            r = np.array([X[i, j, k], Y[i, j, k], Z[i, j, k]])
            diff = r - sun_pos
            dist = np.linalg.norm(diff)

            if dist > 0.1:  # evitar división por cero
                g = -G * sun_mass * diff / dist**3
                gx[i, j, k], gy[i, j, k], gz[i, j, k] = g

# --------------------------
# Plot 3D del campo
# --------------------------
fig = plt.figure(figsize=(10, 7))
ax = fig.add_subplot(111, projection='3d')

ax.quiver(
    X, Y, Z,
    gx, gy, gz,
    length=0.5,
    normalize=True
)

# Mostrar punto del Sol
ax.scatter(0, 0, 0, color='yellow', s=200, label="Sol")

ax.set_title("Campo Gravitacional 3D (quiver)")
ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.set_zlabel("Z")
ax.legend()

plt.show()

'''
Se usa vectores normalizados para hacer la representación del campo
gravitacional del sol.

'''

"""# Simulador del Sistema Solar 3D - Sol y Tierra"""

from mpl_toolkits.mplot3d import Axes3D
from matplotlib import animation

# --- 1. CONSTANTES DEL SISTEMA DE UNIDADES ---
# Unidades: Distancia = AU, Masa = Masa Solar, Tiempo = Años
# En estas unidades, G es igual a 4 * pi^2
G = 4 * (np.pi ** 2)

# --- 2. MOTOR NUMÉRICO (RK4) ---
# El motor matemático es idéntico, solo cambian los números que procesa
def _compute_accelerations(positions, masses):
    n = positions.shape[0]
    acc = np.zeros_like(positions)
    for i in range(n):
        ri = positions[i]
        ai = np.zeros(3)
        for j in range(n):
            if i == j: continue
            r_vec = positions[j] - ri
            dist2 = np.dot(r_vec, r_vec)
            if dist2 == 0: continue
            inv_dist3 = 1.0 / (dist2 * np.sqrt(dist2))
            ai += G * masses[j] * r_vec * inv_dist3
        acc[i] = ai
    return acc

def rk4_step(cuerpos, dt):
    positions = np.array([c['posicion'] for c in cuerpos], dtype=float)
    velocities = np.array([c['velocidad'] for c in cuerpos], dtype=float)
    masses = np.array([c['masa'] for c in cuerpos], dtype=float)

    def deriv(pos, vel):
        return vel, _compute_accelerations(pos, masses)

    v1, a1 = deriv(positions, velocities)
    pos2 = positions + 0.5 * dt * v1
    vel2 = velocities + 0.5 * dt * a1
    v2, a2 = deriv(pos2, vel2)
    pos3 = positions + 0.5 * dt * v2
    vel3 = velocities + 0.5 * dt * a2
    v3, a3 = deriv(pos3, vel3)
    pos4 = positions + dt * v3
    vel4 = velocities + dt * a3
    v4, a4 = deriv(pos4, vel4)

    positions_new = positions + (dt / 6.0) * (v1 + 2*v2 + 2*v3 + v4)
    velocities_new = velocities + (dt / 6.0) * (a1 + 2*a2 + 2*a3 + a4)

    for i, c in enumerate(cuerpos):
        c['posicion'] = positions_new[i]
        c['velocidad'] = velocities_new[i]

# --- 3. CÁLCULOS DE ENERGÍA ---
def energia_cinetica(m, v):
    return 0.5 * m * (np.linalg.norm(v) ** 2)

def energia_potencial(mi, mj, ri, rj):
    diff = rj - ri
    dist = np.linalg.norm(diff)
    if dist == 0: return 0
    return (-G * mi * mj) / dist

def calcula_energia_total(cuerpos):
    ekin = 0
    epot = 0
    for i, cuerpo in enumerate(cuerpos):
        ekin += energia_cinetica(cuerpo['masa'], cuerpo['velocidad'])
        for j, c in enumerate(cuerpos):
            if i != j:
                epot += energia_potencial(cuerpo['masa'], c['masa'],
                                          cuerpo['posicion'], c['posicion'])
    return ekin + (epot / 2)

# --- 4. CARGA DE DATOS Y CONFIGURACIÓN ---

# Tu Data Set Original
planetas_data = [
 {'mass_Msun': 1.0, 'name': 'Sun', 'vx_AUyr': 0.0, 'vy_AUyr': 0.0, 'vz_AUyr': 0.0, 'x_AU': 0.0, 'y_AU': 0.0, 'z_AU': 0.0},
 {'mass_Msun': 1.66e-07, 'name': 'Mercury', 'vx_AUyr': 0.0, 'vy_AUyr': 9.96, 'vz_AUyr': 0.0, 'x_AU': 0.39, 'y_AU': 0.0, 'z_AU': 0.01},
 {'mass_Msun': 2.45e-06, 'name': 'Venus', 'vx_AUyr': 0.0, 'vy_AUyr': 7.39, 'vz_AUyr': 0.0, 'x_AU': 0.72, 'y_AU': 0.0, 'z_AU': -0.01},
 {'mass_Msun': 3e-06, 'name': 'Earth', 'vx_AUyr': 0.0, 'vy_AUyr': 6.28, 'vz_AUyr': 0.0, 'x_AU': 1.0, 'y_AU': 0.0, 'z_AU': 0.0167},
 {'mass_Msun': 3.22e-07, 'name': 'Mars', 'vx_AUyr': 0.0, 'vy_AUyr': 5.08, 'vz_AUyr': 0.0, 'x_AU': 1.52, 'y_AU': 0.0, 'z_AU': 0.04},
 {'mass_Msun': 0.00095, 'name': 'Jupiter', 'vx_AUyr': 0.0, 'vy_AUyr': 2.75, 'vz_AUyr': 0.0, 'x_AU': 5.2, 'y_AU': 0.0, 'z_AU': -0.05},
 {'mass_Msun': 0.00029, 'name': 'Saturn', 'vx_AUyr': 0.0, 'vy_AUyr': 2.03, 'vz_AUyr': 0.0, 'x_AU': 9.5, 'y_AU': 0.0, 'z_AU': 0.1},
 {'mass_Msun': 4.4e-05, 'name': 'Uranus', 'vx_AUyr': 0.0, 'vy_AUyr': 1.43, 'vz_AUyr': 0.0, 'x_AU': 19.2, 'y_AU': 0.0, 'z_AU': -0.2},
 {'mass_Msun': 5.1e-05, 'name': 'Neptune', 'vx_AUyr': 0.0, 'vy_AUyr': 1.14, 'vz_AUyr': 0.0, 'x_AU': 30.1, 'y_AU': 0.0, 'z_AU': 0.3}
]
dff = pd.DataFrame(planetas_data)

# FILTRADO: Solo Sol y Tierra
df_sim = dff[dff['name'].isin(['Sun', 'Earth'])].copy()

# Construcción de la lista 'cuerpos' desde el DataFrame
cuerpos = []
for _, row in df_sim.iterrows():
    cuerpos.append({
        'masa': row['mass_Msun'],
        'posicion': np.array([row['x_AU'], row['y_AU'], row['z_AU']]),
        'velocidad': np.array([row['vx_AUyr'], row['vy_AUyr'], row['vz_AUyr']]),
        'nombre': row['name']
    })

# CONFIGURACIÓN TEMPORAL (En Años)
# dt = 0.002 años (aprox 17 horas, suficiente precisión para RK4)
dt = 0.002
tiempo_total = 2.0 # 2 años de simulación
total_steps = int(tiempo_total / dt)

historia = { 'x': [[],[]], 'y': [[],[]], 'z': [[],[]] }

print(f"Simulando {len(cuerpos)} cuerpos por {tiempo_total} años...")
etot_inicial = calcula_energia_total(cuerpos)

# BUCLE PRINCIPAL
current_step = 0
while current_step < total_steps:
    rk4_step(cuerpos, dt)

    # Guardamos cada paso
    for i, c in enumerate(cuerpos):
        historia['x'][i].append(c['posicion'][0])
        historia['y'][i].append(c['posicion'][1])
        historia['z'][i].append(c['posicion'][2])

    current_step += 1

etot_final = calcula_energia_total(cuerpos)
ratio = abs(etot_inicial) / abs(etot_final) if etot_final != 0 else 0
print(f"Conservación de energía (Ratio): {ratio:.8f}")

# --- 5. VISUALIZACIÓN (Colores Sol y Tierra) ---
from IPython.display import HTML, display

nombres = [c['nombre'] for c in cuerpos]
# Diccionario de colores fijos
mapa_colores = {'Sun': 'gold', 'Earth': 'b'}
colores_plot = [mapa_colores.get(n, 'k') for n in nombres]

visualizacion = input("¿Visualizar resultados? (estatico / animado): ").lower()

if visualizacion == 'estatico':
    plt.rcParams["figure.figsize"] = (12, 6)
    fig = plt.figure()

    # Vista 3D
    ax1 = fig.add_subplot(1, 2, 1, projection='3d')
    for i, nombre in enumerate(nombres):
        # Aumentamos markersize para que el Sol se vea bien
        ms = 10 if nombre == 'Sun' else 4
        ax1.plot(historia['x'][i], historia['y'][i], historia['z'][i],
                 color=colores_plot[i], label=nombre, marker='o', markersize=ms, linestyle='None')
        # Dibujamos también la trayectoria (línea)
        if nombre != 'Sun': # El sol no se mueve mucho, no necesita línea
            ax1.plot(historia['x'][i], historia['y'][i], historia['z'][i],
                     color=colores_plot[i], linewidth=0.5)

    ax1.set_title("Vista 3D (AU)")
    ax1.set_xlabel('X (AU)')
    ax1.set_ylabel('Y (AU)')
    ax1.set_zlabel('Z (AU)')
    ax1.legend()

    # Vista 2D
    ax2 = fig.add_subplot(1, 2, 2)
    for i, nombre in enumerate(nombres):
        ms = 10 if nombre == 'Sun' else 4
        # Trayectoria
        ax2.plot(historia['x'][i], historia['y'][i],
                 color=colores_plot[i], linewidth=1)
        # Posición final (punto)
        ax2.plot(historia['x'][i][-1], historia['y'][i][-1],
                 color=colores_plot[i], label=nombre, marker='o', markersize=ms)

    ax2.set_title("Plano X-Y (AU)")
    ax2.set_xlabel('X (AU)')
    ax2.set_ylabel('Y (AU)')
    ax2.axis('equal') # Mantiene la proporción circular
    ax2.grid(True, alpha=0.3)
    ax2.legend()

    plt.tight_layout()
    plt.show()

elif visualizacion == 'animado':
    plt.rcParams["animation.html"] = "jshtml"
    # Aumentamos el tamaño de la figura para ver mejor
    fig = plt.figure("Simulacion AU", figsize=(8, 8))
    ax = fig.add_subplot(111, projection='3d')

    # Límites fijos basados en AU (-1.5 a 1.5 para ver la órbita de la Tierra completa)
    ax.set_xlim(-1.2, 1.2)
    ax.set_ylim(-1.2, 1.2)
    ax.set_zlim(-1.2, 1.2)
    ax.set_xlabel('X (AU)')
    ax.set_ylabel('Y (AU)')
    ax.set_zlabel('Z (AU)')

    # Inicializamos líneas y puntos
    lines = [ax.plot([], [], [], '-', lw=1, color=colores_plot[i])[0] for i in range(len(cuerpos))]
    # El Sol más grande (markersize=12) que la Tierra (markersize=6)
    points = [ax.plot([], [], [], 'o', markersize=(12 if i==0 else 6), color=colores_plot[i], label=nombres[i])[0] for i in range(len(cuerpos))]

    ax.legend()

    def update(frame):
        for i in range(len(cuerpos)):
            # Trayectoria histórica
            lines[i].set_data(historia['x'][i][:frame], historia['y'][i][:frame])
            lines[i].set_3d_properties(historia['z'][i][:frame])

            # Posición actual (punto)
            points[i].set_data([historia['x'][i][frame]], [historia['y'][i][frame]])
            points[i].set_3d_properties([historia['z'][i][frame]])
        return lines + points

    # Optimizamos frames
    step = max(1, len(historia['x'][0]) // 200)
    ani = animation.FuncAnimation(fig, update, frames=range(0, len(historia['x'][0]), step), interval=30, blit=False)

    display(ani)
    plt.close()

else:
    print ("Intente de nuevo escribiendo 'estatico' o 'animado'.")

"""# Visualización en 3D"""

# nbody_and_field_3d.py
import numpy as np
import pandas as pd

# Visualización
import plotly.graph_objs as go

# Constante G en unidades AU^3 / (Msun * yr^2)
G = 4 * np.pi**2  # ≈ 39.4784176

# ============================================================
#                 1. CARGA DE DATOS DEL CSV
# ============================================================
def load_system(csv_path="solar_system_3d.csv"):
    df = pd.read_csv(csv_path)

    # Asegurar tipo numérico incluso si hay comas
    numeric_cols = ["mass_Msun", "x_AU", "y_AU", "z_AU",
                    "vx_AUyr", "vy_AUyr", "vz_AUyr"]

    for col in numeric_cols:
        df[col] = df[col].astype(str).str.replace(",", ".", regex=False).astype(float)

    names = df["name"].values
    masses = df["mass_Msun"].values                     # (N,)
    pos = df[["x_AU", "y_AU", "z_AU"]].values.astype(float)   # (N,3)
    vel = df[["vx_AUyr", "vy_AUyr", "vz_AUyr"]].values.astype(float)

    return names, masses, pos, vel


# ============================================================
#                 2. ACELERACIONES NBODY
# ============================================================
def accelerations(positions, masses, softening=1e-5):
    """
    positions: (N,3)
    masses: (N,)
    returns: accel (N,3)
    """
    N = positions.shape[0]
    a = np.zeros_like(positions)

    for i in range(N):
        r_ij = positions - positions[i]        # (N,3)
        dist3 = np.sum(r_ij**2, axis=1)**1.5 + softening

        dist3[i] = np.inf  # evitar división por cero

        # broadcasting: masses (N,) -> (N,1)
        contrib = -G * masses[:, None] * r_ij / dist3[:, None]
        a[i] = np.sum(contrib, axis=0)

    return a


# ============================================================
#     3. INTEGRADOR VELOCITY VERLET (SIMPLECTICO)
# ============================================================
def integrate_verlet(positions, velocities, masses, dt, steps, callback=None):
    pos = positions.copy()
    vel = velocities.copy()
    a = accelerations(pos, masses)

    storing = callback is None
    trajectory = []

    for n in range(steps):
        pos += vel * dt + 0.5 * a * dt**2
        a_new = accelerations(pos, masses)
        vel += 0.5 * (a + a_new) * dt
        a = a_new

        if storing:
            trajectory.append(pos.copy())
        else:
            callback(n, pos, vel)

    if storing:
        return np.array(trajectory)
    return None


# ============================================================
#                   4. CAMPO GRAVITACIONAL EN GRILLA 3D
# ============================================================
def compute_field_on_grid(positions, masses, grid_range=(-15, 15), npoints=8, softening=1e-5):
    xs = np.linspace(grid_range[0], grid_range[1], npoints)
    ys = xs.copy()
    zs = xs.copy()
    X, Y, Z = np.meshgrid(xs, ys, zs, indexing='xy')

    U = np.zeros_like(X)
    V = np.zeros_like(Y)
    W = np.zeros_like(Z)

    pts = np.vstack([X.ravel(), Y.ravel(), Z.ravel()]).T  # (M,3)

    for m, pos in zip(masses, positions):
        rvec = pts - pos
        r = np.linalg.norm(rvec, axis=1)
        r3 = r**3 + softening
        a_pts = -G * m * (rvec / r3[:, None])

        U.ravel()[:] += a_pts[:, 0]
        V.ravel()[:] += a_pts[:, 1]
        W.ravel()[:] += a_pts[:, 2]

    return X, Y, Z, U, V, W


# ============================================================
#                       5. VISUALIZACIÓN
# ============================================================
def plot_orbits_animation(trajectory, names, positions0, save_html=None):
    steps, N, _ = trajectory.shape

    fig = go.Figure(
        frames=[
            go.Frame(
                data=[go.Scatter3d(
                    x=trajectory[k, :, 0],
                    y=trajectory[k, :, 1],
                    z=trajectory[k, :, 2],
                    mode='markers',
                    marker=dict(size=4)
                )],
                name=str(k)
            ) for k in range(steps)
        ]
    )

    fig.add_trace(go.Scatter3d(
        x=trajectory[0, :, 0],
        y=trajectory[0, :, 1],
        z=trajectory[0, :, 2],
        mode='markers',
        marker=dict(size=4)
    ))

    # Etiquetas de los cuerpos
    for i, name in enumerate(names):
        fig.add_trace(go.Scatter3d(
            x=[positions0[i, 0]],
            y=[positions0[i, 1]],
            z=[positions0[i, 2]],
            mode='text',
            text=[name],
            showlegend=False
        ))

    fig.update_layout(
        scene=dict(aspectmode='data'),
        updatemenus=[
            dict(
                type='buttons',
                buttons=[
                    dict(
                        label='Play',
                        method='animate',
                        args=[None, dict(frame=dict(duration=50, redraw=True), fromcurrent=True)]
                    )
                ]
            )
        ]
    )

    if save_html:
        fig.write_html(save_html)
    fig.show()


def plot_field_cones(X, Y, Z, U, V, W, bodies_pos=None, bodies_names=None, save_html=None):
    # --- colores para planetas ---
    planet_colors = [
        "red", "orange", "yellow", "green", "blue", "purple",
        "cyan", "magenta", "lime", "gold"
    ]

    # si hay más planetas que colores, repetir la lista
    if bodies_pos is not None and len(bodies_pos) > len(planet_colors):
        import itertools
        planet_colors = list(itertools.islice(itertools.cycle(planet_colors), len(bodies_pos)))

    # --- campo vectorial (conos) ---
    fig = go.Figure(data=go.Cone(
        x=X.ravel(), y=Y.ravel(), z=Z.ravel(),
        u=U.ravel(), v=V.ravel(), w=W.ravel(),
        sizemode="absolute",
        sizeref=0.5,
        colorscale="Viridis",  # color del campo (lo mantenemos uniforme)
        showscale=False
    ))

    # --- planetas con color único ---
    if bodies_pos is not None:
        for i in range(len(bodies_pos)):
            fig.add_trace(go.Scatter3d(
                x=[bodies_pos[i, 0]],
                y=[bodies_pos[i, 1]],
                z=[bodies_pos[i, 2]],
                mode='markers+text',
                marker=dict(size=6, color=planet_colors[i]),
                text=[bodies_names[i]],
                textposition="top center",
                showlegend=False
            ))

    fig.update_layout(
        scene=dict(aspectmode='data'),
        title="Campo gravitacional (conos) + planetas con colores distintos"
    )

    if save_html:
        fig.write_html(save_html)

    fig.show()

# ============================================================
#                     6. EJECUCIÓN DIRECTA
# ============================================================
if __name__ == "__main__":
    names, masses, pos0, vel0 = load_system(r"C:\Users\CixoY\OneDrive\Desktop\cursoanalisis\solar_system_3d.csv")

    # integrar (ejemplo: ~3 años)
    dt = 0.01   # año ~ 3.65 días
    steps = 300
    traj = integrate_verlet(pos0, vel0, masses, dt, steps)

    # animación 3D
    plot_orbits_animation(traj, names, pos0, save_html="orbits_animation.html")

    # campo 3D
    X, Y, Z, U, V, W = compute_field_on_grid(pos0, masses, grid_range=(-35, 35), npoints=10)
    plot_field_cones(X, Y, Z, U, V, W, bodies_pos=pos0, bodies_names=names,
                     save_html="field_cones.html")

